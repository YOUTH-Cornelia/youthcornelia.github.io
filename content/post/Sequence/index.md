---
title: "Can Make Arithmetic Progression From Sequence"
date: 2026-02-07
draft: false
categories: ["LeetCode"]
tags: ["Array"]
leetcode_id: 1502
---

## Description:
[Leetcode 1502. Can Make Arithmetic Progression From Sequence](https://leetcode.cn/problems/can-make-arithmetic-progression-from-sequence/description/?envType=study-plan-v2&envId=programming-skills)

# 关于判断题中 `i` 的初始值、边界与 return 位置的统一理解

## 写这篇的原因

我在写数组 / 字符串判断题时，经常出现以下问题：

* `index out of range`
* 逻辑只检查了第一轮
* `return True / False` 放错位置
* 明明代码“看起来对”，但结果是错的
* 反复纠结 `i` 到底该不该从 0 开始

这些不是零散错误，而是**同一个底层问题反复出现**。


## 一、问题的真正根源

> **我在写代码之前，没有先确定「循环体里会访问哪些下标」。**

我习惯先写：

```python
i = 0
while i < len(arr):
    ...
```

然后在循环体里**临时决定**用：

* `arr[i + 1]`
* `arr[i - 1]`
* `arr[i + 2]`

这是所有问题的起点。

## 二、正确的思考顺序（这是关键）

### ❌ 我以前的顺序（错误）

1. 设 `i = 0`
2. 决定循环到 `len(arr)`
3. 在循环里随便用 `arr[i ± 1]`

### ✅ 正确顺序（必须反过来）

1. **先确定循环体里会访问哪些下标**
2. 算出这些下标对 `i` 的最小 / 最大要求
3. 再由此决定：

   * `i` 的初始值
   * 循环终止条件

一句话总结：

> **下标决定 `i`，不是 `i` 决定下标。**


## 三、`i` 的初始值到底和什么有关

只和一件事有关：

> **循环体中，最左会访问到哪个下标**


### 情况 1：只用当前元素

```python
arr[i]
```

* 要求：`i >= 0`
* 结论：`i` 可以从 `0` 开始


### 情况 2：用前一个元素

```python
arr[i - 1]
```

* 要求：`i - 1 >= 0`
* 推出：`i >= 1`
* 结论：`i` **必须从 1 开始**

⚠️ 注意：
在 Python 中，`arr[-1]` **不会报错**，但逻辑已经错了，这是最危险的情况。


### 情况 3：用后一个元素

```python
arr[i + 1]
```

* 要求：`i + 1 < len(arr)`
* 推出：`i < len(arr) - 1`
* 结论：`i` 可以从 0 开始，但**终点要收紧**


### 情况 4：同时用前后

```python
arr[i - 1], arr[i], arr[i + 1]
```

* 起点：`i >= 1`
* 终点：`i < len(arr) - 1`


## 四、统一成一张可直接套用的规则表

| 循环体中使用的下标                   | `i` 的起点 | 循环条件               |
| --------------------------- | ------- | ------------------ |
| `arr[i]`                    | `0`     | `i < len(arr)`     |
| `arr[i + 1]`                | `0`     | `i < len(arr) - 1` |
| `arr[i - 1]`                | `1`     | `i < len(arr)`     |
| `arr[i - 1]` + `arr[i]`     | `1`     | `i < len(arr)`     |
| `arr[i - 1]` + `arr[i + 1]` | `1`     | `i < len(arr) - 1` |


## 五、`index out of range` 的真实含义

这个错误不表示我“写错代码”，而是表示：

> **我的循环条件，没有覆盖我在循环体里用到的最大下标偏移。**

处理方法不是试错，而是机械计算：

1. 找出 `i` 的最大偏移量（`+k` 或 `-k`）
2. 确保：

   * 左边：`i - k >= 0`
   * 右边：`i + k < len(arr)`


## 六、判断题中另一个致命问题：`return` 的位置

很多题（等差数列、字符串规则判断）问的是：

> **是不是所有位置都满足条件**

但我习惯写成：

```python
if 条件成立:
    return True
return False
```

这只检查了**第一个样本**。

## 七、判断题的唯一正确结构

### 如果题目问的是「是否是 / 是否能构成 / 是否全部满足」

**结构必须是：**

```python
for ...:
    if 不满足条件:
        return False
return True
```

硬规则：

> **判断“是不是”的题，循环里只能早退 False，不能早退 True。**


## 八、把所有问题合并成一套执行流程

以后我写数组 / 字符串判断题，必须按这个顺序：

1. **先判断问题类型**

   * 找一个 → 可以早退 True
   * 全部满足 → 只能早退 False
2. **明确循环体里访问的所有下标**
3. **由下标反推出 `i` 的起点和终点**
4. **最后才写代码**

任何一步没做，代码都不可信。

## 九、最终结论

我之前反复纠结的：

* `i` 能不能从 0 开始
* 为什么老是越界
* 为什么逻辑只对一半

本质都不是细节问题，而是：

> **没有在写循环前完成“下标建模”。**

一旦下标模型确定：

* `i` 的初始值是确定的
* 边界是确定的
* `return` 的位置也是确定的
